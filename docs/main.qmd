# The Python Project *and* Package manager, uv
## Introduction

::: {.callout-important}
**Note, use CMD-K CMD-S to open the keyboard shortcuts.**
`SHFT-CMD-i` inserts a code block
:::

`uv` is an Open Source project by `Astral`, the makers of `ruff`, that is self described (and worthy of the title) as 

> **pull** from their docs here.


I'm only just beginning to learn and use the tool in my own projects (including converting my existing project environments to uv) and from what I've seen it's going to make life much easier. That being said, while you overwrite the muscle memory developed for years with `pip` and `venv`, there will be some growing pains; however, for those who are less familiar with what I'm talking about, I'll still explain some basic concepts and snags that I both run and ran into.

## Basic workflow and guide
### Concepts to Know Before Getting Started {#sec-0-prereq}
- Basic knowledge of directories, bash (zsh in the case of MacOS), and using the CLI [bash resources](https://www.DataCamp.com/)
- Basic knowledge of Python, common project structures, and simple workflows [Python resources](https://www.python.org/)
- Basic knowledge of git (for local version control) and GitHub (for collaboration) [git and GitHub basics](https://www.GitHub.com/)
- Basic knowledge of Quarto for documention [Quarto](https://www.quarto.org/)

### Initializing a Project {#sec-1-init}
#### Local Repository
The nice thing about `uv` is that it's designed to make Python development easier, so there aren't any head-scratching gotchas.

For the sake of this example and entire template, let's assume I'm currently sitting in my `main` directory. For some that might be `home`, others `app`, for MacOS the default is `/usr/yourusername`, or maybe you prefer to put all projects in a `Documents` or `Projects` folder. Anyways, to start up a project you can do one of two things:

1. Have uv do everything, and then change directories
   1. ```
   uv init uv_basic
   cd uv_basic
   ```
2. Create the directory, change directories, and then have uv do everything
   1. ```
   mkdir uv_basic
   cd uv_basic
   uv init
   ```

This will create 4 files and initalize a local git repository:
1. `.python-version`
2. `.pyproject.toml`
3. `hello.py`
4. `README.md`
5. `.git`
6. `.gitignore`

:::{.callout-tip}
# uv and the .gitignore file
The nice thing about `uv` is that it autopopulates your `.gitignore` file with a few files and patterns, not to mention, it provides some basic tagging for what it puts in there. Just open the file (it's plain text) to see. Since I'm saving my progress with this repo using git, I want to keep the overall file size down. So, I also included the `.html` and `.ipynb` file that Quarto generates because they can get large fast.
:::

#### Remote Repository
For anyone familiar with software development you've probably heard of GitHub or GitLab. I'm more familiar, professionally and personally, with GitHub (which is what I'll be using in this example); however, there are a large amount of people that prefer GitLab because it is better for some enterprise and personal use cases-- **TL;DR** `...`. For this, you'll want to install the [GitHub CLI](https://www.github.com/cli/). Then, you can follow along.

1. Make sure to get your credentials setup, in git
   1. A
   2. B
   3. C
   4. D
   5. E
2. Check that GitHub CLI is installed and verify by looking at which repos you have access to
   1. `which gh`
3. Assuming you haven't, create your project repo from the CLI
   1. `gh repo create`
   2. `Create a new repository from scratch`
   3. `uv basic`
   4. *optional description*
   5. `Public`
   6. `GNU Affero General Public License v3.0` **See note on licenses for more info (add section and link here)**
   7. **Add images here**
4. Set the newly created repo as the local git repo's upstream
   1. This will result in an error (`git pull`)
   2. Set the global config to merge **Link to resources explainin merge v. rebase v. ff**
   3. git pull with a commit message
   4. git status to verify
   5. git push

### Adding and managing dependencies {#sec-2-dep}

## General Notes
- It seems that while tools are specific to a uv project instance (i.e. uv_basic returns the .venv dir when asking which jupyter, but test before intalling anything say it can't be found), when you use uv tool install it installs it to the system wide uv
- `uv pip list` defaults to the global (non-uv or non-pip) python environment (in my case it's pip and wheel), but once you install something (using add, pip install, etc.) it switches the context to the current parent uv dir (i.e. test, instead of uv_basic)
  - Tools are still listed even after this
- `uv tool install` only works when installing python package specific tools, but DuckDB for Python (for example) doesn't come packaged with the DuckDB CLI tools, so `uv tool install duckdb` won't install the DuckDB CLI features
- It seems that saving variable with duckdb.sql(...).show() and then printing the type of that, just prints the query output, insteaed of the type
- Based on tests, the workflow changes are as follows
- Worth noting, the below code does not account for git creation or management

### pip/classic format
```
mkdir uv_basic
cd uv_basic
python -m venv .venv
source .venv/bin/activate
pip install duckdb

# Write your script
"""
import duckdb

def main():
        test = duckdb.sql("SELECT 42")

        return print(type(test))

if __name__ == '__main__':
   main()
"""

python script.py
# <class 'duckdb.duckdb.DuckDBPyRelation'>
deactivate

```
### uv format

```
cd home
uv init uv_basic
cd uv_basic
uv add duckdb

# Write your script
"""
import duckdb

def main():
        test = duckdb.sql("SELECT 42")

        return print(type(test))

if __name__ == '__main__':
   main()
"""

uv run test.py 
# <class 'duckdb.duckdb.DuckDBPyRelation'> 
```